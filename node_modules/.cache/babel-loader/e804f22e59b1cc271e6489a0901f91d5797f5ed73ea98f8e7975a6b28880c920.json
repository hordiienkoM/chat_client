{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2021-2022 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nrequire(\"core-js/modules/es.array.push.js\");\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n      label: 0,\n      sent: function () {\n        if (t[0] & 1) throw t[1];\n        return t[1];\n      },\n      trys: [],\n      ops: []\n    },\n    f,\n    y,\n    t,\n    g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n        case 7:\n          op = _.ops.pop();\n          _.trys.pop();\n          continue;\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n            _.ops.push(op);\n            break;\n          }\n          if (t[2]) _.ops.pop();\n          _.trys.pop();\n          continue;\n      }\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n    m = s && o[s],\n    i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WellKnownMimeTypeEntry = exports.ReservedMimeTypeEntry = exports.ExplicitMimeTimeEntry = exports.decodeCompositeMetadata = exports.encodeWellKnownMetadataHeader = exports.encodeCustomMetadataHeader = exports.decodeMimeTypeFromMimeBuffer = exports.decodeMimeAndContentBuffersSlices = exports.encodeAndAddWellKnownMetadata = exports.encodeAndAddCustomMetadata = exports.encodeCompositeMetadata = exports.CompositeMetadata = void 0;\nvar rsocket_core_1 = require(\"rsocket-core\");\nvar WellKnownMimeType_1 = require(\"./WellKnownMimeType\");\nvar CompositeMetadata = /** @class */function () {\n  function CompositeMetadata(buffer) {\n    this._buffer = buffer;\n  }\n  CompositeMetadata.prototype.iterator = function () {\n    return decodeCompositeMetadata(this._buffer);\n  };\n  CompositeMetadata.prototype[Symbol.iterator] = function () {\n    return decodeCompositeMetadata(this._buffer);\n  };\n  return CompositeMetadata;\n}();\nexports.CompositeMetadata = CompositeMetadata;\nfunction encodeCompositeMetadata(metadata) {\n  var e_1, _a;\n  var encodedCompositeMetadata = Buffer.allocUnsafe(0);\n  try {\n    for (var metadata_1 = __values(metadata), metadata_1_1 = metadata_1.next(); !metadata_1_1.done; metadata_1_1 = metadata_1.next()) {\n      var _b = __read(metadata_1_1.value, 2),\n        metadataKey = _b[0],\n        metadataValue = _b[1];\n      var metadataRealValue = typeof metadataValue === \"function\" ? metadataValue() : metadataValue;\n      if (metadataKey instanceof WellKnownMimeType_1.WellKnownMimeType || typeof metadataKey === \"number\" || metadataKey.constructor.name === \"WellKnownMimeType\") {\n        encodedCompositeMetadata = encodeAndAddWellKnownMetadata(encodedCompositeMetadata, metadataKey, metadataRealValue);\n      } else {\n        encodedCompositeMetadata = encodeAndAddCustomMetadata(encodedCompositeMetadata, metadataKey, metadataRealValue);\n      }\n    }\n  } catch (e_1_1) {\n    e_1 = {\n      error: e_1_1\n    };\n  } finally {\n    try {\n      if (metadata_1_1 && !metadata_1_1.done && (_a = metadata_1.return)) _a.call(metadata_1);\n    } finally {\n      if (e_1) throw e_1.error;\n    }\n  }\n  return encodedCompositeMetadata;\n}\nexports.encodeCompositeMetadata = encodeCompositeMetadata;\n// see #encodeMetadataHeader(ByteBufAllocator, String, int)\nfunction encodeAndAddCustomMetadata(compositeMetaData, customMimeType, metadata) {\n  return Buffer.concat([compositeMetaData, encodeCustomMetadataHeader(customMimeType, metadata.byteLength), metadata]);\n}\nexports.encodeAndAddCustomMetadata = encodeAndAddCustomMetadata;\n// see #encodeMetadataHeader(ByteBufAllocator, byte, int)\nfunction encodeAndAddWellKnownMetadata(compositeMetadata, knownMimeType, metadata) {\n  var mimeTypeId;\n  if (Number.isInteger(knownMimeType)) {\n    mimeTypeId = knownMimeType;\n  } else {\n    mimeTypeId = knownMimeType.identifier;\n  }\n  return Buffer.concat([compositeMetadata, encodeWellKnownMetadataHeader(mimeTypeId, metadata.byteLength), metadata]);\n}\nexports.encodeAndAddWellKnownMetadata = encodeAndAddWellKnownMetadata;\nfunction decodeMimeAndContentBuffersSlices(compositeMetadata, entryIndex) {\n  var mimeIdOrLength = compositeMetadata.readInt8(entryIndex);\n  var mime;\n  var toSkip = entryIndex;\n  if ((mimeIdOrLength & STREAM_METADATA_KNOWN_MASK) === STREAM_METADATA_KNOWN_MASK) {\n    mime = compositeMetadata.slice(toSkip, toSkip + 1);\n    toSkip += 1;\n  } else {\n    // M flag unset, remaining 7 bits are the length of the mime\n    var mimeLength = (mimeIdOrLength & 0xff) + 1;\n    if (compositeMetadata.byteLength > toSkip + mimeLength) {\n      // need to be able to read an extra mimeLength bytes (we have already read one so byteLength should be strictly more)\n      // here we need a way for the returned ByteBuf to differentiate between a\n      // 1-byte length mime type and a 1 byte encoded mime id, preferably without\n      // re-applying the byte mask. The easiest way is to include the initial byte\n      // and have further decoding ignore the first byte. 1 byte buffer == id, 2+ byte\n      // buffer == full mime string.\n      mime = compositeMetadata.slice(toSkip, toSkip + mimeLength + 1);\n      // we thus need to skip the bytes we just sliced, but not the flag/length byte\n      // which was already skipped in initial read\n      toSkip += mimeLength + 1;\n    } else {\n      throw new Error(\"Metadata is malformed. Inappropriately formed Mime Length\");\n    }\n  }\n  if (compositeMetadata.byteLength >= toSkip + 3) {\n    // ensures the length medium can be read\n    var metadataLength = (0, rsocket_core_1.readUInt24BE)(compositeMetadata, toSkip);\n    toSkip += 3;\n    if (compositeMetadata.byteLength >= metadataLength + toSkip) {\n      var metadata = compositeMetadata.slice(toSkip, toSkip + metadataLength);\n      return [mime, metadata];\n    } else {\n      throw new Error(\"Metadata is malformed. Inappropriately formed Metadata Length or malformed content\");\n    }\n  } else {\n    throw new Error(\"Metadata is malformed. Metadata Length is absent or malformed\");\n  }\n}\nexports.decodeMimeAndContentBuffersSlices = decodeMimeAndContentBuffersSlices;\nfunction decodeMimeTypeFromMimeBuffer(flyweightMimeBuffer) {\n  if (flyweightMimeBuffer.length < 2) {\n    throw new Error(\"Unable to decode explicit MIME type\");\n  }\n  // the encoded length is assumed to be kept at the start of the buffer\n  // but also assumed to be irrelevant because the rest of the slice length\n  // actually already matches _decoded_length\n  return flyweightMimeBuffer.toString(\"ascii\", 1);\n}\nexports.decodeMimeTypeFromMimeBuffer = decodeMimeTypeFromMimeBuffer;\nfunction encodeCustomMetadataHeader(customMime, metadataLength) {\n  // allocate one byte + the length of the mimetype\n  var metadataHeader = Buffer.allocUnsafe(4 + customMime.length);\n  // fill the buffer to clear previous memory\n  metadataHeader.fill(0);\n  // write the custom mime in UTF8 but validate it is all ASCII-compatible\n  // (which produces the correct result since ASCII chars are still encoded on 1 byte in UTF8)\n  var customMimeLength = metadataHeader.write(customMime, 1);\n  if (!isAscii(metadataHeader, 1)) {\n    throw new Error(\"Custom mime type must be US_ASCII characters only\");\n  }\n  if (customMimeLength < 1 || customMimeLength > 128) {\n    throw new Error(\"Custom mime type must have a strictly positive length that fits on 7 unsigned bits, ie 1-128\");\n  }\n  // encoded length is one less than actual length, since 0 is never a valid length, which gives\n  // wider representation range\n  metadataHeader.writeUInt8(customMimeLength - 1);\n  (0, rsocket_core_1.writeUInt24BE)(metadataHeader, metadataLength, customMimeLength + 1);\n  return metadataHeader;\n}\nexports.encodeCustomMetadataHeader = encodeCustomMetadataHeader;\nfunction encodeWellKnownMetadataHeader(mimeType, metadataLength) {\n  var buffer = Buffer.allocUnsafe(4);\n  buffer.writeUInt8(mimeType | STREAM_METADATA_KNOWN_MASK);\n  (0, rsocket_core_1.writeUInt24BE)(buffer, metadataLength, 1);\n  return buffer;\n}\nexports.encodeWellKnownMetadataHeader = encodeWellKnownMetadataHeader;\nfunction decodeCompositeMetadata(buffer) {\n  var length, entryIndex, headerAndData, header, data, typeString, id, type;\n  return __generator(this, function (_a) {\n    switch (_a.label) {\n      case 0:\n        length = buffer.byteLength;\n        entryIndex = 0;\n        _a.label = 1;\n      case 1:\n        if (!(entryIndex < length)) return [3 /*break*/, 7];\n        headerAndData = decodeMimeAndContentBuffersSlices(buffer, entryIndex);\n        header = headerAndData[0];\n        data = headerAndData[1];\n        entryIndex = computeNextEntryIndex(entryIndex, header, data);\n        if (!!isWellKnownMimeType(header)) return [3 /*break*/, 3];\n        typeString = decodeMimeTypeFromMimeBuffer(header);\n        if (!typeString) {\n          throw new Error(\"MIME type cannot be null\");\n        }\n        return [4 /*yield*/, new ExplicitMimeTimeEntry(data, typeString)];\n      case 2:\n        _a.sent();\n        return [3 /*break*/, 1];\n      case 3:\n        id = decodeMimeIdFromMimeBuffer(header);\n        type = WellKnownMimeType_1.WellKnownMimeType.fromIdentifier(id);\n        if (!(WellKnownMimeType_1.WellKnownMimeType.UNKNOWN_RESERVED_MIME_TYPE === type)) return [3 /*break*/, 5];\n        return [4 /*yield*/, new ReservedMimeTypeEntry(data, id)];\n      case 4:\n        _a.sent();\n        return [3 /*break*/, 1];\n      case 5:\n        return [4 /*yield*/, new WellKnownMimeTypeEntry(data, type)];\n      case 6:\n        _a.sent();\n        return [3 /*break*/, 1];\n      case 7:\n        return [2 /*return*/];\n    }\n  });\n}\n\nexports.decodeCompositeMetadata = decodeCompositeMetadata;\nvar ExplicitMimeTimeEntry = /** @class */function () {\n  function ExplicitMimeTimeEntry(content, type) {\n    this.content = content;\n    this.type = type;\n  }\n  return ExplicitMimeTimeEntry;\n}();\nexports.ExplicitMimeTimeEntry = ExplicitMimeTimeEntry;\nvar ReservedMimeTypeEntry = /** @class */function () {\n  function ReservedMimeTypeEntry(content, type) {\n    this.content = content;\n    this.type = type;\n  }\n  Object.defineProperty(ReservedMimeTypeEntry.prototype, \"mimeType\", {\n    /**\n     * Since this entry represents a compressed id that couldn't be decoded, this is\n     * always {@code null}.\n     */\n    get: function () {\n      return undefined;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  return ReservedMimeTypeEntry;\n}();\nexports.ReservedMimeTypeEntry = ReservedMimeTypeEntry;\nvar WellKnownMimeTypeEntry = /** @class */function () {\n  function WellKnownMimeTypeEntry(content, type) {\n    this.content = content;\n    this.type = type;\n  }\n  Object.defineProperty(WellKnownMimeTypeEntry.prototype, \"mimeType\", {\n    get: function () {\n      return this.type.string;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  return WellKnownMimeTypeEntry;\n}();\nexports.WellKnownMimeTypeEntry = WellKnownMimeTypeEntry;\nfunction decodeMimeIdFromMimeBuffer(mimeBuffer) {\n  if (!isWellKnownMimeType(mimeBuffer)) {\n    return WellKnownMimeType_1.WellKnownMimeType.UNPARSEABLE_MIME_TYPE.identifier;\n  }\n  return mimeBuffer.readInt8() & STREAM_METADATA_LENGTH_MASK;\n}\nfunction computeNextEntryIndex(currentEntryIndex, headerSlice, contentSlice) {\n  return currentEntryIndex + headerSlice.byteLength +\n  // this includes the mime length byte\n  3 +\n  // 3 bytes of the content length, which are excluded from the slice\n  contentSlice.byteLength;\n}\nfunction isWellKnownMimeType(header) {\n  return header.byteLength === 1;\n}\nvar STREAM_METADATA_KNOWN_MASK = 0x80; // 1000 0000\nvar STREAM_METADATA_LENGTH_MASK = 0x7f; // 0111 1111\nfunction isAscii(buffer, offset) {\n  var isAscii = true;\n  for (var i = offset, length_1 = buffer.length; i < length_1; i++) {\n    if (buffer[i] > 127) {\n      isAscii = false;\n      break;\n    }\n  }\n  return isAscii;\n}","map":{"version":3,"names":["require","rsocket_core_1","WellKnownMimeType_1","CompositeMetadata","buffer","_buffer","prototype","iterator","decodeCompositeMetadata","Symbol","exports","encodeCompositeMetadata","metadata","encodedCompositeMetadata","Buffer","allocUnsafe","metadata_1","__values","metadata_1_1","next","done","_b","__read","value","metadataKey","metadataValue","metadataRealValue","WellKnownMimeType","constructor","name","encodeAndAddWellKnownMetadata","encodeAndAddCustomMetadata","compositeMetaData","customMimeType","concat","encodeCustomMetadataHeader","byteLength","compositeMetadata","knownMimeType","mimeTypeId","Number","isInteger","identifier","encodeWellKnownMetadataHeader","decodeMimeAndContentBuffersSlices","entryIndex","mimeIdOrLength","readInt8","mime","toSkip","STREAM_METADATA_KNOWN_MASK","slice","mimeLength","Error","metadataLength","readUInt24BE","decodeMimeTypeFromMimeBuffer","flyweightMimeBuffer","length","toString","customMime","metadataHeader","fill","customMimeLength","write","isAscii","writeUInt8","writeUInt24BE","mimeType","headerAndData","header","data","computeNextEntryIndex","isWellKnownMimeType","typeString","ExplicitMimeTimeEntry","_a","sent","id","decodeMimeIdFromMimeBuffer","type","fromIdentifier","UNKNOWN_RESERVED_MIME_TYPE","ReservedMimeTypeEntry","WellKnownMimeTypeEntry","content","Object","defineProperty","get","undefined","string","mimeBuffer","UNPARSEABLE_MIME_TYPE","STREAM_METADATA_LENGTH_MASK","currentEntryIndex","headerSlice","contentSlice","offset","i","length_1"],"sources":["../src/CompositeMetadata.ts"],"sourcesContent":[null],"mappings":";;AAAA;;;;;;;;;;;;;;;AAAAA,OAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgBA,IAAAC,cAAA,GAAAD,OAAA;AACA,IAAAE,mBAAA,GAAAF,OAAA;AAEA,IAAAG,iBAAA;EAGE,SAAAA,kBAAYC,MAAc;IACxB,IAAI,CAACC,OAAO,GAAGD,MAAM;EACvB;EAEAD,iBAAA,CAAAG,SAAA,CAAAC,QAAQ,GAAR;IACE,OAAOC,uBAAuB,CAAC,IAAI,CAACH,OAAO,CAAC;EAC9C,CAAC;EAEDF,iBAAA,CAAAG,SAAA,CAACG,MAAM,CAACF,QAAQ,CAAC,GAAjB;IACE,OAAOC,uBAAuB,CAAC,IAAI,CAACH,OAAO,CAAC;EAC9C,CAAC;EACH,OAAAF,iBAAC;AAAD,CAAC,CAdD;AAAaO,OAAA,CAAAP,iBAAA,GAAAA,iBAAA;AAgBb,SAAgBQ,uBAAuBA,CACrCC,QAEyE;;EAEzE,IAAIC,wBAAwB,GAAGC,MAAM,CAACC,WAAW,CAAC,CAAC,CAAC;;IACpD,KAA2C,IAAAC,UAAA,GAAAC,QAAA,CAAAL,QAAQ,GAAAM,YAAA,GAAAF,UAAA,CAAAG,IAAA,KAAAD,YAAA,CAAAE,IAAA,EAAAF,YAAA,GAAAF,UAAA,CAAAG,IAAA,IAAE;MAA1C,IAAAE,EAAA,GAAAC,MAAA,CAAAJ,YAAA,CAAAK,KAAA,IAA4B;QAA3BC,WAAW,GAAAH,EAAA;QAAEI,aAAa,GAAAJ,EAAA;MACpC,IAAMK,iBAAiB,GACrB,OAAOD,aAAa,KAAK,UAAU,GAAGA,aAAa,EAAE,GAAGA,aAAa;MAEvE,IACED,WAAW,YAAYtB,mBAAA,CAAAyB,iBAAiB,IACxC,OAAOH,WAAW,KAAK,QAAQ,IAC/BA,WAAW,CAACI,WAAW,CAACC,IAAI,KAAK,mBAAmB,EACpD;QACAhB,wBAAwB,GAAGiB,6BAA6B,CACtDjB,wBAAwB,EACxBW,WAAyC,EACzCE,iBAAiB,CAClB;OACF,MAAM;QACLb,wBAAwB,GAAGkB,0BAA0B,CACnDlB,wBAAwB,EACxBW,WAAW,EACXE,iBAAiB,CAClB;;;;;;;;;;;;;;EAIL,OAAOb,wBAAwB;AACjC;AA9BAH,OAAA,CAAAC,uBAAA,GAAAA,uBAAA;AAgCA;AACA,SAAgBoB,0BAA0BA,CACxCC,iBAAyB,EACzBC,cAAsB,EACtBrB,QAAgB;EAEhB,OAAOE,MAAM,CAACoB,MAAM,CAAC,CACnBF,iBAAiB,EACjBG,0BAA0B,CAACF,cAAc,EAAErB,QAAQ,CAACwB,UAAU,CAAC,EAC/DxB,QAAQ,CACT,CAAC;AACJ;AAVAF,OAAA,CAAAqB,0BAAA,GAAAA,0BAAA;AAYA;AACA,SAAgBD,6BAA6BA,CAC3CO,iBAAyB,EACzBC,aAAyC,EACzC1B,QAAgB;EAEhB,IAAI2B,UAAkB;EAEtB,IAAIC,MAAM,CAACC,SAAS,CAACH,aAAa,CAAC,EAAE;IACnCC,UAAU,GAAGD,aAAuB;GACrC,MAAM;IACLC,UAAU,GAAID,aAAmC,CAACI,UAAU;;EAG9D,OAAO5B,MAAM,CAACoB,MAAM,CAAC,CACnBG,iBAAiB,EACjBM,6BAA6B,CAACJ,UAAU,EAAE3B,QAAQ,CAACwB,UAAU,CAAC,EAC9DxB,QAAQ,CACT,CAAC;AACJ;AAlBAF,OAAA,CAAAoB,6BAAA,GAAAA,6BAAA;AAoBA,SAAgBc,iCAAiCA,CAC/CP,iBAAyB,EACzBQ,UAAkB;EAElB,IAAMC,cAAc,GAAWT,iBAAiB,CAACU,QAAQ,CAACF,UAAU,CAAC;EACrE,IAAIG,IAAY;EAChB,IAAIC,MAAM,GAAGJ,UAAU;EACvB,IACE,CAACC,cAAc,GAAGI,0BAA0B,MAC5CA,0BAA0B,EAC1B;IACAF,IAAI,GAAGX,iBAAiB,CAACc,KAAK,CAACF,MAAM,EAAEA,MAAM,GAAG,CAAC,CAAC;IAClDA,MAAM,IAAI,CAAC;GACZ,MAAM;IACL;IACA,IAAMG,UAAU,GAAG,CAACN,cAAc,GAAG,IAAI,IAAI,CAAC;IAE9C,IAAIT,iBAAiB,CAACD,UAAU,GAAGa,MAAM,GAAGG,UAAU,EAAE;MACtD;MACA;MACA;MACA;MACA;MACA;MACAJ,IAAI,GAAGX,iBAAiB,CAACc,KAAK,CAACF,MAAM,EAAEA,MAAM,GAAGG,UAAU,GAAG,CAAC,CAAC;MAE/D;MACA;MACAH,MAAM,IAAIG,UAAU,GAAG,CAAC;KACzB,MAAM;MACL,MAAM,IAAIC,KAAK,CACb,2DAA2D,CAC5D;;;EAIL,IAAIhB,iBAAiB,CAACD,UAAU,IAAIa,MAAM,GAAG,CAAC,EAAE;IAC9C;IACA,IAAMK,cAAc,GAAG,IAAArD,cAAA,CAAAsD,YAAY,EAAClB,iBAAiB,EAAEY,MAAM,CAAC;IAC9DA,MAAM,IAAI,CAAC;IACX,IAAIZ,iBAAiB,CAACD,UAAU,IAAIkB,cAAc,GAAGL,MAAM,EAAE;MAC3D,IAAMrC,QAAQ,GAAGyB,iBAAiB,CAACc,KAAK,CAACF,MAAM,EAAEA,MAAM,GAAGK,cAAc,CAAC;MACzE,OAAO,CAACN,IAAI,EAAEpC,QAAQ,CAAC;KACxB,MAAM;MACL,MAAM,IAAIyC,KAAK,CACb,oFAAoF,CACrF;;GAEJ,MAAM;IACL,MAAM,IAAIA,KAAK,CACb,+DAA+D,CAChE;;AAEL;AArDA3C,OAAA,CAAAkC,iCAAA,GAAAA,iCAAA;AAuDA,SAAgBY,4BAA4BA,CAC1CC,mBAA2B;EAE3B,IAAIA,mBAAmB,CAACC,MAAM,GAAG,CAAC,EAAE;IAClC,MAAM,IAAIL,KAAK,CAAC,qCAAqC,CAAC;;EAExD;EACA;EACA;EACA,OAAOI,mBAAmB,CAACE,QAAQ,CAAC,OAAO,EAAE,CAAC,CAAC;AACjD;AAVAjD,OAAA,CAAA8C,4BAAA,GAAAA,4BAAA;AAYA,SAAgBrB,0BAA0BA,CACxCyB,UAAkB,EAClBN,cAAsB;EAEtB;EACA,IAAMO,cAAc,GAAW/C,MAAM,CAACC,WAAW,CAAC,CAAC,GAAG6C,UAAU,CAACF,MAAM,CAAC;EAExE;EACAG,cAAc,CAACC,IAAI,CAAC,CAAC,CAAC;EAEtB;EACA;EACA,IAAMC,gBAAgB,GAAWF,cAAc,CAACG,KAAK,CAACJ,UAAU,EAAE,CAAC,CAAC;EACpE,IAAI,CAACK,OAAO,CAACJ,cAAc,EAAE,CAAC,CAAC,EAAE;IAC/B,MAAM,IAAIR,KAAK,CAAC,mDAAmD,CAAC;;EAEtE,IAAIU,gBAAgB,GAAG,CAAC,IAAIA,gBAAgB,GAAG,GAAG,EAAE;IAClD,MAAM,IAAIV,KAAK,CACb,8FAA8F,CAC/F;;EAEH;EACA;EACAQ,cAAc,CAACK,UAAU,CAACH,gBAAgB,GAAG,CAAC,CAAC;EAE/C,IAAA9D,cAAA,CAAAkE,aAAa,EAACN,cAAc,EAAEP,cAAc,EAAES,gBAAgB,GAAG,CAAC,CAAC;EAEnE,OAAOF,cAAc;AACvB;AA5BAnD,OAAA,CAAAyB,0BAAA,GAAAA,0BAAA;AA8BA,SAAgBQ,6BAA6BA,CAC3CyB,QAAgB,EAChBd,cAAsB;EAEtB,IAAMlD,MAAM,GAAWU,MAAM,CAACC,WAAW,CAAC,CAAC,CAAC;EAE5CX,MAAM,CAAC8D,UAAU,CAACE,QAAQ,GAAGlB,0BAA0B,CAAC;EACxD,IAAAjD,cAAA,CAAAkE,aAAa,EAAC/D,MAAM,EAAEkD,cAAc,EAAE,CAAC,CAAC;EAExC,OAAOlD,MAAM;AACf;AAVAM,OAAA,CAAAiC,6BAAA,GAAAA,6BAAA;AAYA,SAAiBnC,uBAAuBA,CACtCJ,MAAc;;;;;QAERsD,MAAM,GAAGtD,MAAM,CAACgC,UAAU;QAC5BS,UAAU,GAAG,CAAC;;;cAEXA,UAAU,GAAGa,MAAM;QAClBW,aAAa,GAAGzB,iCAAiC,CAACxC,MAAM,EAAEyC,UAAU,CAAC;QAErEyB,MAAM,GAAGD,aAAa,CAAC,CAAC,CAAC;QACzBE,IAAI,GAAGF,aAAa,CAAC,CAAC,CAAC;QAE7BxB,UAAU,GAAG2B,qBAAqB,CAAC3B,UAAU,EAAEyB,MAAM,EAAEC,IAAI,CAAC;aAExD,CAACE,mBAAmB,CAACH,MAAM,CAAC,EAA5B;QACII,UAAU,GAAGlB,4BAA4B,CAACc,MAAM,CAAC;QACvD,IAAI,CAACI,UAAU,EAAE;UACf,MAAM,IAAIrB,KAAK,CAAC,0BAA0B,CAAC;;QAG7C,qBAAM,IAAIsB,qBAAqB,CAACJ,IAAI,EAAEG,UAAU,CAAC;;QAAjDE,EAAA,CAAAC,IAAA,EAAiD;QACjD;;QAGIC,EAAE,GAAGC,0BAA0B,CAACT,MAAM,CAAC;QACvCU,IAAI,GAAG9E,mBAAA,CAAAyB,iBAAiB,CAACsD,cAAc,CAACH,EAAE,CAAC;cAC7C5E,mBAAA,CAAAyB,iBAAiB,CAACuD,0BAA0B,KAAKF,IAAI,GAArD;QACF,qBAAM,IAAIG,qBAAqB,CAACZ,IAAI,EAAEO,EAAE,CAAC;;QAAzCF,EAAA,CAAAC,IAAA,EAAyC;QACzC;;QAGF,qBAAM,IAAIO,sBAAsB,CAACb,IAAI,EAAES,IAAI,CAAC;;QAA5CJ,EAAA,CAAAC,IAAA,EAA4C;;;;;;;;AA/BhDnE,OAAA,CAAAF,uBAAA,GAAAA,uBAAA;AAmDA,IAAAmE,qBAAA;EACE,SAAAA,sBAAqBU,OAAe,EAAWL,IAAY;IAAtC,KAAAK,OAAO,GAAPA,OAAO;IAAmB,KAAAL,IAAI,GAAJA,IAAI;EAAW;EAChE,OAAAL,qBAAC;AAAD,CAAC,CAFD;AAAajE,OAAA,CAAAiE,qBAAA,GAAAA,qBAAA;AAIb,IAAAQ,qBAAA;EACE,SAAAA,sBAAqBE,OAAe,EAAWL,IAAY;IAAtC,KAAAK,OAAO,GAAPA,OAAO;IAAmB,KAAAL,IAAI,GAAJA,IAAI;EAAW;EAM9DM,MAAA,CAAAC,cAAA,CAAIJ,qBAAA,CAAA7E,SAAA,YAAQ;IAJZ;;;;SAIA,SAAAkF,CAAA;MACE,OAAOC,SAAS;IAClB,CAAC;;;;EACH,OAAAN,qBAAC;AAAD,CAAC,CAVD;AAAazE,OAAA,CAAAyE,qBAAA,GAAAA,qBAAA;AAYb,IAAAC,sBAAA;EACE,SAAAA,uBAAqBC,OAAe,EAAWL,IAAuB;IAAjD,KAAAK,OAAO,GAAPA,OAAO;IAAmB,KAAAL,IAAI,GAAJA,IAAI;EAAsB;EAEzEM,MAAA,CAAAC,cAAA,CAAIH,sBAAA,CAAA9E,SAAA,YAAQ;SAAZ,SAAAkF,CAAA;MACE,OAAO,IAAI,CAACR,IAAI,CAACU,MAAM;IACzB,CAAC;;;;EACH,OAAAN,sBAAC;AAAD,CAAC,CAND;AAAa1E,OAAA,CAAA0E,sBAAA,GAAAA,sBAAA;AAQb,SAASL,0BAA0BA,CAACY,UAAkB;EACpD,IAAI,CAAClB,mBAAmB,CAACkB,UAAU,CAAC,EAAE;IACpC,OAAOzF,mBAAA,CAAAyB,iBAAiB,CAACiE,qBAAqB,CAAClD,UAAU;;EAE3D,OAAOiD,UAAU,CAAC5C,QAAQ,EAAE,GAAG8C,2BAA2B;AAC5D;AAEA,SAASrB,qBAAqBA,CAC5BsB,iBAAyB,EACzBC,WAAmB,EACnBC,YAAoB;EAEpB,OACEF,iBAAiB,GACjBC,WAAW,CAAC3D,UAAU;EAAG;EACzB,CAAC;EAAG;EACJ4D,YAAY,CAAC5D,UAAU;AAE3B;AAEA,SAASqC,mBAAmBA,CAACH,MAAc;EACzC,OAAOA,MAAM,CAAClC,UAAU,KAAK,CAAC;AAChC;AAEA,IAAMc,0BAA0B,GAAG,IAAI,CAAC,CAAC;AACzC,IAAM2C,2BAA2B,GAAG,IAAI,CAAC,CAAC;AAE1C,SAAS5B,OAAOA,CAAC7D,MAAc,EAAE6F,MAAc;EAC7C,IAAIhC,OAAO,GAAG,IAAI;EAClB,KAAK,IAAIiC,CAAC,GAAGD,MAAM,EAAEE,QAAM,GAAG/F,MAAM,CAACsD,MAAM,EAAEwC,CAAC,GAAGC,QAAM,EAAED,CAAC,EAAE,EAAE;IAC5D,IAAI9F,MAAM,CAAC8F,CAAC,CAAC,GAAG,GAAG,EAAE;MACnBjC,OAAO,GAAG,KAAK;MACf;;;EAIJ,OAAOA,OAAO;AAChB"},"metadata":{},"sourceType":"script","externalDependencies":[]}