{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2021-2022 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n    m = s && o[s],\n    i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WellKnownAuthType = void 0;\nvar WellKnownAuthType = /** @class */function () {\n  function WellKnownAuthType(string, identifier) {\n    this.string = string;\n    this.identifier = identifier;\n  }\n  /**\n   * Find the {@link WellKnownAuthType} for the given identifier (as an {@link number}). Valid\n   * identifiers are defined to be integers between 0 and 127, inclusive. Identifiers outside of\n   * this range will produce the {@link #UNPARSEABLE_AUTH_TYPE}. Additionally, some identifiers in\n   * that range are still only reserved and don't have a type associated yet: this method returns\n   * the {@link #UNKNOWN_RESERVED_AUTH_TYPE} when passing such an identifier, which lets call sites\n   * potentially detect this and keep the original representation when transmitting the associated\n   * metadata buffer.\n   *\n   * @param id the looked up identifier\n   * @return the {@link WellKnownAuthType}, or {@link #UNKNOWN_RESERVED_AUTH_TYPE} if the id is out\n   *     of the specification's range, or {@link #UNKNOWN_RESERVED_AUTH_TYPE} if the id is one that\n   *     is merely reserved but unknown to this implementation.\n   */\n  WellKnownAuthType.fromIdentifier = function (id) {\n    if (id < 0x00 || id > 0x7f) {\n      return WellKnownAuthType.UNPARSEABLE_AUTH_TYPE;\n    }\n    return WellKnownAuthType.TYPES_BY_AUTH_ID[id];\n  };\n  /**\n   * Find the {@link WellKnownAuthType} for the given {@link String} representation. If the\n   * representation is {@code null} or doesn't match a {@link WellKnownAuthType}, the {@link\n   * #UNPARSEABLE_AUTH_TYPE} is returned.\n   *\n   * @param authTypeString the looked up mime type\n   * @return the matching {@link WellKnownAuthType}, or {@link #UNPARSEABLE_AUTH_TYPE} if none\n   *     matches\n   */\n  WellKnownAuthType.fromString = function (authTypeString) {\n    if (!authTypeString) {\n      throw new Error(\"type must be non-null\");\n    }\n    // force UNPARSEABLE if by chance UNKNOWN_RESERVED_MIME_TYPE's text has been used\n    if (authTypeString === WellKnownAuthType.UNKNOWN_RESERVED_AUTH_TYPE.string) {\n      return WellKnownAuthType.UNPARSEABLE_AUTH_TYPE;\n    }\n    return WellKnownAuthType.TYPES_BY_AUTH_STRING.get(authTypeString) || WellKnownAuthType.UNPARSEABLE_AUTH_TYPE;\n  };\n  /** @see #string() */\n  WellKnownAuthType.prototype.toString = function () {\n    return this.string;\n  };\n  return WellKnownAuthType;\n}();\nexports.WellKnownAuthType = WellKnownAuthType;\n(function (WellKnownAuthType) {\n  var e_1, _a;\n  WellKnownAuthType.UNPARSEABLE_AUTH_TYPE = new WellKnownAuthType(\"UNPARSEABLE_AUTH_TYPE_DO_NOT_USE\", -2);\n  WellKnownAuthType.UNKNOWN_RESERVED_AUTH_TYPE = new WellKnownAuthType(\"UNKNOWN_YET_RESERVED_DO_NOT_USE\", -1);\n  WellKnownAuthType.SIMPLE = new WellKnownAuthType(\"simple\", 0x00);\n  WellKnownAuthType.BEARER = new WellKnownAuthType(\"bearer\", 0x01);\n  WellKnownAuthType.TYPES_BY_AUTH_ID = new Array(128);\n  WellKnownAuthType.TYPES_BY_AUTH_STRING = new Map();\n  var ALL_MIME_TYPES = [WellKnownAuthType.UNPARSEABLE_AUTH_TYPE, WellKnownAuthType.UNKNOWN_RESERVED_AUTH_TYPE, WellKnownAuthType.SIMPLE, WellKnownAuthType.BEARER];\n  WellKnownAuthType.TYPES_BY_AUTH_ID.fill(WellKnownAuthType.UNKNOWN_RESERVED_AUTH_TYPE);\n  try {\n    for (var ALL_MIME_TYPES_1 = __values(ALL_MIME_TYPES), ALL_MIME_TYPES_1_1 = ALL_MIME_TYPES_1.next(); !ALL_MIME_TYPES_1_1.done; ALL_MIME_TYPES_1_1 = ALL_MIME_TYPES_1.next()) {\n      var value = ALL_MIME_TYPES_1_1.value;\n      if (value.identifier >= 0) {\n        WellKnownAuthType.TYPES_BY_AUTH_ID[value.identifier] = value;\n        WellKnownAuthType.TYPES_BY_AUTH_STRING.set(value.string, value);\n      }\n    }\n  } catch (e_1_1) {\n    e_1 = {\n      error: e_1_1\n    };\n  } finally {\n    try {\n      if (ALL_MIME_TYPES_1_1 && !ALL_MIME_TYPES_1_1.done && (_a = ALL_MIME_TYPES_1.return)) _a.call(ALL_MIME_TYPES_1);\n    } finally {\n      if (e_1) throw e_1.error;\n    }\n  }\n  if (Object.seal) {\n    Object.seal(WellKnownAuthType.TYPES_BY_AUTH_ID);\n  }\n})(WellKnownAuthType = exports.WellKnownAuthType || (exports.WellKnownAuthType = {}));\nexports.WellKnownAuthType = WellKnownAuthType;","map":{"version":3,"names":["WellKnownAuthType","string","identifier","fromIdentifier","id","UNPARSEABLE_AUTH_TYPE","TYPES_BY_AUTH_ID","fromString","authTypeString","Error","UNKNOWN_RESERVED_AUTH_TYPE","TYPES_BY_AUTH_STRING","get","prototype","toString","exports","SIMPLE","BEARER","Array","Map","ALL_MIME_TYPES","fill","ALL_MIME_TYPES_1","__values","ALL_MIME_TYPES_1_1","next","done","value","set","Object","seal"],"sources":["../src/WellKnownAuthType.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}