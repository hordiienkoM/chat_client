{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2021-2022 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decodeSimpleAuthPayload = exports.decodeAuthMetadata = exports.encodeBearerAuthMetadata = exports.encodeSimpleAuthMetadata = exports.encodeCustomAuthMetadata = exports.encodeWellKnownAuthMetadata = void 0;\nvar WellKnownAuthType_1 = require(\"./WellKnownAuthType\");\nvar authTypeIdBytesLength = 1;\nvar customAuthTypeBytesLength = 1;\nvar usernameLengthBytesLength = 2;\nvar streamMetadataKnownMask = 0x80; // 1000 0000\nvar streamMetadataLengthMask = 0x7f; // 0111 1111\n/**\n * Encode Auth metadata with the given {@link WellKnownAuthType} and auth payload {@link Buffer}\n *\n * @param authType well known auth type\n * @param authPayloadBuffer auth payload buffer\n * @returns encoded {@link WellKnownAuthType} and payload {@link Buffer}\n */\nfunction encodeWellKnownAuthMetadata(authType, authPayloadBuffer) {\n  if (authType === WellKnownAuthType_1.WellKnownAuthType.UNPARSEABLE_AUTH_TYPE || authType === WellKnownAuthType_1.WellKnownAuthType.UNKNOWN_RESERVED_AUTH_TYPE) {\n    throw new Error(\"Illegal WellKnownAuthType[\".concat(authType.toString(), \"]. Only allowed AuthType should be used\"));\n  }\n  var buffer = Buffer.allocUnsafe(authTypeIdBytesLength);\n  // eslint-disable-next-line no-bitwise\n  buffer.writeUInt8(authType.identifier | streamMetadataKnownMask);\n  return Buffer.concat([buffer, authPayloadBuffer]);\n}\nexports.encodeWellKnownAuthMetadata = encodeWellKnownAuthMetadata;\n/**\n * Encode Auth metadata with the given custom auth type {@link string} and auth payload {@link Buffer}\n *\n * @param customAuthType custom auth type\n * @param authPayloadBuffer auth payload buffer\n * @returns encoded {@link WellKnownAuthType} and payload {@link Buffer}\n */\nfunction encodeCustomAuthMetadata(customAuthType, authPayloadBuffer) {\n  var customAuthTypeBuffer = Buffer.from(customAuthType);\n  if (customAuthTypeBuffer.byteLength !== customAuthType.length) {\n    throw new Error(\"Custom auth type must be US_ASCII characters only\");\n  }\n  if (customAuthTypeBuffer.byteLength < 1 || customAuthTypeBuffer.byteLength > 128) {\n    throw new Error(\"Custom auth type must have a strictly positive length that fits on 7 unsigned bits, ie 1-128\");\n  }\n  var buffer = Buffer.allocUnsafe(customAuthTypeBytesLength + customAuthTypeBuffer.byteLength);\n  // encoded length is one less than actual length, since 0 is never a valid length, which gives\n  // wider representation range\n  buffer.writeUInt8(customAuthTypeBuffer.byteLength - 1);\n  buffer.write(customAuthType, customAuthTypeBytesLength);\n  return Buffer.concat([buffer, authPayloadBuffer]);\n}\nexports.encodeCustomAuthMetadata = encodeCustomAuthMetadata;\n/**\n * Encode Simple Auth metadata with the given username and password\n *\n * @param username username\n * @param password password\n * @returns encoded {@link SIMPLE} and given username and password as auth payload {@link Buffer}\n */\nfunction encodeSimpleAuthMetadata(username, password) {\n  var usernameBuffer = Buffer.from(username);\n  var passwordBuffer = Buffer.from(password);\n  var usernameLength = usernameBuffer.byteLength;\n  if (usernameLength > 65535) {\n    throw new Error(\"Username should be shorter than or equal to 65535 bytes length in UTF-8 encoding but the given was \".concat(usernameLength));\n  }\n  var capacity = authTypeIdBytesLength + usernameLengthBytesLength;\n  var buffer = Buffer.allocUnsafe(capacity);\n  // eslint-disable-next-line no-bitwise\n  buffer.writeUInt8(WellKnownAuthType_1.WellKnownAuthType.SIMPLE.identifier | streamMetadataKnownMask);\n  buffer.writeUInt16BE(usernameLength, 1);\n  return Buffer.concat([buffer, usernameBuffer, passwordBuffer]);\n}\nexports.encodeSimpleAuthMetadata = encodeSimpleAuthMetadata;\n/**\n * Encode Bearer Auth metadata with the given token\n *\n * @param token token\n * @returns encoded {@link BEARER} and given token as auth payload {@link Buffer}\n */\nfunction encodeBearerAuthMetadata(token) {\n  var tokenBuffer = Buffer.from(token);\n  var buffer = Buffer.allocUnsafe(authTypeIdBytesLength);\n  // eslint-disable-next-line no-bitwise\n  buffer.writeUInt8(WellKnownAuthType_1.WellKnownAuthType.BEARER.identifier | streamMetadataKnownMask);\n  return Buffer.concat([buffer, tokenBuffer]);\n}\nexports.encodeBearerAuthMetadata = encodeBearerAuthMetadata;\n/**\n * Decode auth metadata {@link Buffer} into {@link AuthMetadata} object\n *\n * @param metadata auth metadata {@link Buffer}\n * @returns decoded {@link AuthMetadata}\n */\nfunction decodeAuthMetadata(metadata) {\n  if (metadata.byteLength < 1) {\n    throw new Error(\"Unable to decode Auth metadata. Not enough readable bytes\");\n  }\n  var lengthOrId = metadata.readUInt8();\n  // eslint-disable-next-line no-bitwise\n  var normalizedId = lengthOrId & streamMetadataLengthMask;\n  if (normalizedId !== lengthOrId) {\n    var authType = WellKnownAuthType_1.WellKnownAuthType.fromIdentifier(normalizedId);\n    return {\n      payload: metadata.slice(1),\n      type: {\n        identifier: authType.identifier,\n        string: authType.string\n      }\n    };\n  } else {\n    // encoded length is realLength - 1 in order to avoid intersection with 0x00 authtype\n    var realLength = lengthOrId + 1;\n    if (metadata.byteLength < realLength + customAuthTypeBytesLength) {\n      throw new Error(\"Unable to decode custom Auth type. Malformed length or auth type string\");\n    }\n    var customAuthTypeString = metadata.toString(\"utf8\", customAuthTypeBytesLength, customAuthTypeBytesLength + realLength);\n    var payload = metadata.slice(realLength + customAuthTypeBytesLength);\n    return {\n      payload: payload,\n      type: {\n        identifier: WellKnownAuthType_1.WellKnownAuthType.UNPARSEABLE_AUTH_TYPE.identifier,\n        string: customAuthTypeString\n      }\n    };\n  }\n}\nexports.decodeAuthMetadata = decodeAuthMetadata;\n/**\n * Read up to 129 bytes from the given metadata in order to get the custom Auth Type\n *\n * @param authPayload\n * @return sliced username and password buffers\n */\nfunction decodeSimpleAuthPayload(authPayload) {\n  if (authPayload.byteLength < usernameLengthBytesLength) {\n    throw new Error(\"Unable to decode Simple Auth Payload. Not enough readable bytes\");\n  }\n  var usernameLength = authPayload.readUInt16BE();\n  if (authPayload.byteLength < usernameLength + usernameLengthBytesLength) {\n    throw new Error(\"Unable to decode Simple Auth Payload. Not enough readable bytes\");\n  }\n  var username = authPayload.slice(usernameLengthBytesLength, usernameLengthBytesLength + usernameLength);\n  var password = authPayload.slice(usernameLengthBytesLength + usernameLength);\n  return {\n    password: password,\n    username: username\n  };\n}\nexports.decodeSimpleAuthPayload = decodeSimpleAuthPayload;","map":{"version":3,"names":["WellKnownAuthType_1","require","authTypeIdBytesLength","customAuthTypeBytesLength","usernameLengthBytesLength","streamMetadataKnownMask","streamMetadataLengthMask","encodeWellKnownAuthMetadata","authType","authPayloadBuffer","WellKnownAuthType","UNPARSEABLE_AUTH_TYPE","UNKNOWN_RESERVED_AUTH_TYPE","Error","concat","toString","buffer","Buffer","allocUnsafe","writeUInt8","identifier","exports","encodeCustomAuthMetadata","customAuthType","customAuthTypeBuffer","from","byteLength","length","write","encodeSimpleAuthMetadata","username","password","usernameBuffer","passwordBuffer","usernameLength","capacity","SIMPLE","writeUInt16BE","encodeBearerAuthMetadata","token","tokenBuffer","BEARER","decodeAuthMetadata","metadata","lengthOrId","readUInt8","normalizedId","fromIdentifier","payload","slice","type","string","realLength","customAuthTypeString","decodeSimpleAuthPayload","authPayload","readUInt16BE"],"sources":["../src/AuthMetadata.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}