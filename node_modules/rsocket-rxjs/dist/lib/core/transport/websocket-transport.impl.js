import { webSocket } from 'rxjs/webSocket';
import { defer, ReplaySubject } from "rxjs";
import { Frame, FrameType } from "../protocol/frame";
import { map, takeUntil } from 'rxjs/operators';
import { logFrame } from '../../utlities/debugging';
import { factory } from '../config-log4j';
const log = factory.getLogger('.transport.Websocket');
export class WebsocketTransport {
    constructor(url) {
        this.url = url;
        this._sendPosition = 0;
        this._recvPosition = 0;
        this._foreignRecvPosition = 0;
        this._closed = new ReplaySubject();
        log.debug(`Constructing websocket with target url ${url}`);
        this.subject = webSocket({
            url: this.url,
            binaryType: "arraybuffer",
            serializer: (a) => {
                return a;
            },
            deserializer: a => {
                return a.data;
            },
            openObserver: {
                next: event => log.debug('Websocket opened'),
                error: err => log.error('Error', err)
            },
            closeObserver: {
                next: event => {
                    // this._closed.complete();
                    log.debug('Websocket closed. ' + JSON.stringify(event));
                },
                error: err => log.error('Error', err)
            },
            closingObserver: {
                next: event => {
                    console.log("Closing websocket");
                    log.debug('Closing Websocket due to unsubscribe');
                },
                error: err => log.error('Error', err)
            }
        });
        if (typeof window !== "undefined") {
            window.addEventListener('unload', event => this.close().subscribe());
        }
    }
    close() {
        return defer(() => {
            // if (this.subject !== undefined) {
            //     this.subject.complete();
            // }
            this._closed.complete();
            if (this.subject != undefined) {
                this.subject.complete();
            }
            return this._closed;
        });
    }
    incoming() {
        return this.subject.pipe(map(data => {
            const frame = new Frame(new Uint8Array(data));
            logFrame(frame, false);
            this._recvPosition += data.byteLength;
            if (frame.type() == FrameType.KEEPALIVE) {
                this._foreignRecvPosition = frame.lastReceivedPosition();
            }
            return frame;
        }), takeUntil(this._closed));
    }
    send(frame) {
        logFrame(frame, true);
        this._sendPosition += frame.buffer.byteLength;
        this.subject.next(frame.buffer);
    }
    sendPosition() {
        return this._sendPosition;
    }
    recvPosition() {
        return this._recvPosition;
    }
    foreignRecvPosition() {
        return this._foreignRecvPosition;
    }
}
