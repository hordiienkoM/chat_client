import { defer } from "rxjs";
import { map } from "rxjs/operators";
import { Payload } from "../core/protocol/payload";
import { decodeAuthentication, decodeCompositeMetadata, decodeJson, decodeMessageAcceptMimeTypes, decodeMessageMimeType, decodeMessageRoute, encodeAuthentication, encodeCompositionMetadata, encodeJson, encodeMessageAcceptMimeTypes, encodeMessageMimeType, encodeMessageRoute } from "./encoder/message-x-rsocket";
import { TextCoding } from "./encoder/text.encoder";
import { WellKnownMimeTypes } from "./well-known-mime-types";
export class EncodingRSocket {
    constructor(rsocket) {
        this.rsocket = rsocket;
        this._encoder = new Map();
        this._decoder = new Map();
        this.addDecoder({
            mimeType: WellKnownMimeTypes.MESSAGE_X_RSOCKET_COMPOSITE_METADATA_V0.name,
            decode: decodeCompositeMetadata
        })
            .addEncoder({
            mimeType: WellKnownMimeTypes.MESSAGE_X_RSOCKET_COMPOSITE_METADATA_V0.name,
            encode: encodeCompositionMetadata
        })
            .addDecoder({
            mimeType: WellKnownMimeTypes.MESSAGE_X_RSOCKET_ACCEPT_MIME_TYPES_V0.name,
            decode: decodeMessageAcceptMimeTypes
        })
            .addEncoder({
            mimeType: WellKnownMimeTypes.MESSAGE_X_RSOCKET_ACCEPT_MIME_TYPES_V0.name,
            encode: encodeMessageAcceptMimeTypes
        })
            .addDecoder({
            mimeType: WellKnownMimeTypes.MESSAGE_X_RSOCKET_MIME_TYPE_V0.name,
            decode: decodeMessageMimeType
        })
            .addEncoder({
            mimeType: WellKnownMimeTypes.MESSAGE_X_RSOCKET_MIME_TYPE_V0.name,
            encode: encodeMessageMimeType
        })
            .addDecoder({
            mimeType: WellKnownMimeTypes.APPLICATION_JSON.name,
            decode: decodeJson
        }).addEncoder({
            mimeType: WellKnownMimeTypes.APPLICATION_JSON.name,
            encode: encodeJson
        })
            .addDecoder({
            mimeType: WellKnownMimeTypes.APPLICATION_OCTET_STREAM.name,
            decode: (buffer, socket) => buffer
        })
            .addEncoder({
            mimeType: WellKnownMimeTypes.APPLICATION_OCTET_STREAM.name,
            encode: (buffer, socket) => buffer
        })
            .addDecoder({
            mimeType: WellKnownMimeTypes.MESSAGE_X_RSOCKET_ROUTING_V0.name,
            decode: decodeMessageRoute
        }).addEncoder({
            mimeType: WellKnownMimeTypes.MESSAGE_X_RSOCKET_ROUTING_V0.name,
            encode: encodeMessageRoute
        }).addDecoder({
            mimeType: WellKnownMimeTypes.MESSAGE_X_RSOCKET_AUTHENTICATION_V0.name,
            decode: decodeAuthentication
        }).addEncoder({
            mimeType: WellKnownMimeTypes.MESSAGE_X_RSOCKET_AUTHENTICATION_V0.name,
            encode: encodeAuthentication
        })
            .addDecoder({
            mimeType: WellKnownMimeTypes.TEXT_PLAIN.name,
            decode: TextCoding.Plain.decoder
        })
            .addEncoder({
            mimeType: WellKnownMimeTypes.TEXT_PLAIN.name,
            encode: TextCoding.Plain.encoder
        });
    }
    get responder() {
        return this.rsocket.responder;
    }
    close() {
        return this.rsocket.close();
    }
    state() {
        return this.rsocket.state();
    }
    addEncoder(encoder) {
        this._encoder.set(encoder.mimeType, encoder);
        return this;
    }
    addDecoder(decoder) {
        this._decoder.set(decoder.mimeType, decoder);
        return this;
    }
    removeEncoder(mimeType) {
        this._encoder.delete(mimeType);
        return this;
    }
    removeDecoder(mimeType) {
        this._decoder.delete(mimeType);
        return this;
    }
    requestResponse(payload, options) {
        return defer(() => {
            let encodedPayload = this.tryEncodePayload(payload);
            return this.rsocket.requestResponse(encodedPayload);
        }).pipe(map(res => this.tryDecodePayload(res, options)));
    }
    requestStream(payload, requester, options) {
        let encodedPayload = this.tryEncodePayload(payload);
        return this.rsocket.requestStream(encodedPayload, requester).pipe(map(res => this.tryDecodePayload(res, options)));
    }
    requestFNF(payload) {
        this.rsocket.requestFNF(this.tryEncodePayload(payload));
    }
    setResponder(responder) {
        this.rsocket.responder = responder;
    }
    tryEncodePayload(payload) {
        let data = new Uint8Array(0);
        let metadata = new Uint8Array(0);
        if (payload.data != undefined) {
            data = this.tryEncodeObject(payload.data, payload.dataMimeType != undefined ? payload.dataMimeType : this.getSetupConfig().dataMimeType);
        }
        if (payload.metadata != undefined) {
            metadata = this.tryEncodeObject(payload.metadata, payload.metadataMimeType != undefined ? payload.metadataMimeType : this.getSetupConfig().metadataMimeType);
        }
        return new Payload(data, metadata);
    }
    tryEncodeObject(object, mimeType) {
        if (this._encoder.has(mimeType)) {
            return this._encoder.get(mimeType).encode(object, this);
        }
        else {
            throw new Error(`No encoder for MimeType ${mimeType} available!`);
        }
    }
    tryDecodePayload(payload, options) {
        let data = undefined;
        let metadata = undefined;
        if (options == undefined) {
            options = {
                responseDataMimeType: this.rsocket.getSetupConfig().dataMimeType,
                responseMetadataMimeType: this.rsocket.getSetupConfig().metadataMimeType,
            };
        }
        if (options.responseDataMimeType == undefined) {
            options.responseDataMimeType = this.rsocket.getSetupConfig().dataMimeType;
        }
        if (options.responseMetadataMimeType == undefined) {
            options.responseMetadataMimeType = this.rsocket.getSetupConfig().metadataMimeType;
        }
        data = this.tryDecodeObject(payload.data, options.responseDataMimeType);
        if (payload.hasMetadata()) {
            metadata = this.tryDecodeObject(payload.metadata, options.responseMetadataMimeType);
        }
        return {
            data: data,
            dataMimeType: options.responseDataMimeType,
            metadata: metadata,
            metadataMimeType: metadata != undefined ? options.responseMetadataMimeType : undefined
        };
    }
    tryDecodeObject(buffer, mimeType) {
        if (this._decoder.has(mimeType)) {
            return this._decoder.get(mimeType).decode(buffer, this);
        }
        else {
            throw new Error(`No decoder for MimeType ${mimeType} available!`);
        }
    }
    getSetupConfig() {
        return this.rsocket.getSetupConfig();
    }
}
