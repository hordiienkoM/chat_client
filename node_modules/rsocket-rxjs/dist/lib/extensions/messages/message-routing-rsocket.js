import { Observable, of } from "rxjs";
import { map } from "rxjs/operators";
import { CompositeMetadata } from "../composite-metadata";
import { WellKnownMimeTypes } from "../well-known-mime-types";
import { RSocketRoutingResponder } from "./rsocket-routing-responder";
export class MessageRoutingRSocket {
    constructor(parent) {
        this.parent = parent;
        this._responder = new RSocketRoutingResponder(parent);
        parent.setResponder(this._responder);
    }
    get responder() {
        return this._responder;
    }
    simpleRequestResponse(route, data, authentication) {
        return this.requestResponse({
            route: route,
            data: data,
            authentication: authentication
        }).pipe(map(res => res.data));
    }
    requestResponse(payload, options) {
        if (this._isCompositeMetadataRequest(payload)) {
            return this.parent.requestResponse({
                data: payload.data,
                dataMimeType: payload.dataMimeType,
                metadata: this._constructCompositeMetadata(payload),
                metadataMimeType: WellKnownMimeTypes.MESSAGE_X_RSOCKET_COMPOSITE_METADATA_V0.name
            }, options);
        }
        else {
            throw new Error('Only CompositeMetaData requests are implemented');
        }
    }
    simpleRequestStream(route, data, requester, authentication) {
        return this.requestStream({
            route: route,
            data: data,
            authentication: authentication
        }, requester).pipe(map(ans => ans.data));
    }
    requestStream(payload, requester, options) {
        if (this._isCompositeMetadataRequest(payload)) {
            return this.parent.requestStream({
                data: payload.data,
                dataMimeType: payload.dataMimeType,
                metadata: this._constructCompositeMetadata(payload),
                metadataMimeType: WellKnownMimeTypes.MESSAGE_X_RSOCKET_COMPOSITE_METADATA_V0.name
            }, requester, options);
        }
        else {
            throw new Error('Only CompositeMetaData requests are implemented');
        }
    }
    simpleRequestFNF(route, data, authentication) {
        this.requestFNF({
            route: route,
            data: data,
            authentication: authentication
        });
    }
    requestFNF(payload) {
        if (this._isCompositeMetadataRequest(payload)) {
            return this.parent.requestFNF({
                data: payload.data,
                dataMimeType: payload.dataMimeType,
                metadata: this._constructCompositeMetadata(payload),
                metadataMimeType: WellKnownMimeTypes.MESSAGE_X_RSOCKET_COMPOSITE_METADATA_V0.name
            });
        }
        else {
            throw new Error('Only CompositeMetaData requests are implemented');
        }
    }
    addRequestResponseHandler(route, handler, options = {
        payloadType: 'dataOnly'
    }) {
        let mappingHandler = (payload) => {
            const handlerResponse = handler(payload.data, payload.metadata);
            let responseObservable;
            if (handlerResponse instanceof Observable) {
                responseObservable = handlerResponse;
            }
            else {
                responseObservable = of(handlerResponse);
            }
            if (options.payloadType === 'dataOnly') {
                return responseObservable.pipe(map(v => ({ data: v })));
            }
            else if (options.payloadType === 'decodedPayload') {
                return responseObservable;
            }
        };
        this.responder.addRequestResponseHandler(route, mappingHandler, options === null || options === void 0 ? void 0 : options.encodingOptions);
    }
    addRequestStreamHandler(route, handler, options = {
        payloadType: 'dataOnly'
    }) {
        this.responder.addRequestStreamHandler(route, this._createMappingHandler(handler, options), options === null || options === void 0 ? void 0 : options.encodingOptions);
    }
    addFireAndForgetHandler(route, handler, options) {
        this.responder.addRequestFNFHandler(route, (payload) => {
            handler(payload.data, payload.metadata);
        }, options);
    }
    _createMappingHandler(handler, options) {
        let mappingHandler = (payload) => {
            const handlerResponse = handler(payload.data, payload.metadata);
            let responseObservable;
            if (handlerResponse instanceof Observable) {
                responseObservable = handlerResponse;
            }
            else {
                responseObservable = of(handlerResponse);
            }
            if (options.payloadType === 'dataOnly') {
                return responseObservable.pipe(map(v => ({ data: v })));
            }
            else if (options.payloadType === 'decodedPayload') {
                return responseObservable;
            }
        };
        return mappingHandler;
    }
    close() {
        return this.parent.close();
    }
    state() {
        return this.parent.state();
    }
    getSetupConfig() {
        return this.parent.getSetupConfig();
    }
    _isCompositeMetadataRequest(payload) {
        return (payload.metadataMimeType && payload.metadataMimeType == WellKnownMimeTypes.MESSAGE_X_RSOCKET_COMPOSITE_METADATA_V0.name)
            || this.getSetupConfig().metadataMimeType == WellKnownMimeTypes.MESSAGE_X_RSOCKET_COMPOSITE_METADATA_V0.name;
    }
    _constructCompositeMetadata(payload) {
        const metadata = payload.metadata == undefined ? new CompositeMetadata() : payload.metadata;
        metadata.push({
            mimeType: WellKnownMimeTypes.MESSAGE_X_RSOCKET_ROUTING_V0.name,
            data: payload.route
        });
        if (payload.authentication) {
            metadata.push({
                mimeType: WellKnownMimeTypes.MESSAGE_X_RSOCKET_AUTHENTICATION_V0.name,
                data: payload.authentication
            });
        }
        return metadata;
    }
}
